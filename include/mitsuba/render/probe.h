//
// Created by Jiatian Sun on 8/31/18.
//

#pragma once

#if !defined(__MITSUBA_RENDER_PROBE_H_)
#define __MITSUBA_RENDER_PROBE_H_

#include <mitsuba/mitsuba.h>
#include <mitsuba/render/common.h>
#include <mitsuba/core/netobject.h>
#include <mitsuba/core/properties.h>
#include <mitsuba/core/track.h>
#include <mitsuba/core/cobject.h>
#include <mitsuba/core/aabb.h>
//#include <mitsuba/render/shader.h>
//#include <mitsuba/render/mipmap.h>

MTS_NAMESPACE_BEGIN

class MTS_EXPORT_RENDER Probe : public ConfigurableObject {
public:
    enum EProbeType {
        ENORMAL = 0X00,
        EIDENTITY = 0X01,
        EROW = 0X02,
        ECOLUMN = 0X04,
        EDISPARITY = 0X08,
        EEPIPOLAR = 0x10
    };

    enum EImportanceType {
        ECAM = 0x00,
        EPROJ = 0x01
    };

    /// Serialize this probing pattern to a binary data stream
    virtual void serialize(Stream *stream, InstanceManager *manager) const;

    /// Add a child ConfigurableObject
    virtual void addChild(const std::string &name, ConfigurableObject *child);

    /// Add an unnamed child
    inline void addChild(ConfigurableObject *child) { addChild("", child); }

    virtual void readFromCamera(Stream *stream);

    virtual void readFromProjector(Stream *stream);

    virtual void configureAfterLoadingCamProj();

    // =============================================================
    //! @{ \name Sampling interface
    // =============================================================

    /**
     * \brief Importance sample the spatial component of the
     * emission profile.
     *
     * This function takes an uniformly distributed 2D vector
     * and maps it to a position on the surface of the emitter.
     *
     * Some implementations may choose to implement extra functionality
     * based on the value of \c extra: for instance, Sensors
     * (which are a subclass of \ref AbstractEmitter) perform uniform
     * sampling over the entire image plane if <tt>extra == NULL</tt>,
     * but other values, they will restrict sampling to a pixel-sized
     * rectangle with that offset.
     *
     * The default implementation throws an exception.
     *
     * \param pRec
     *    A position record to be populated with the sampled
     *    position and related information
     *
     * \param sample
     *    A uniformly distributed 2D vector (or any value,
     *    when \ref needsPositionSample() == \c false)
     *
     * \param extra
     *    An additional 2D vector provided to the sampling
     *    routine -- its use is implementation-dependent.
     *
     * \return
     *    An importance weight associated with the sampled position.
     *    This accounts for the difference between the spatial part of the
     *    emission profile and the density function.
     */
    virtual Spectrum sampleCameraPosition(PositionSamplingRecord &pRec,
                                          const Point2 &sample, const Point2 *extra = NULL) const;

    virtual Spectrum sampleProjectorPosition(PositionSamplingRecord &pRec, Sampler *sampler,
                                             const Point2 &sample, const Point2 *extra = NULL) const;

    /**
     * \brief Conditioned on the spatial component, importance
     * sample the directional part of the emission profile.
     *
     * Some implementations may choose to implement extra functionality
     * based on the value of \c extra: for instance, Sensors
     * (which are a subclass of \ref AbstractEmitter) perform uniform
     * sampling over the entire image plane if <tt>extra == NULL</tt>,
     * but other values, they will restrict sampling to a pixel-sized
     * rectangle with that offset.
     *
     * The default implementation throws an exception.
     *
     * \param dRec
     *    A direction record to be populated with the sampled
     *    direction and related information
     *
     * \param pRec
     *    A position record generated by a preceding call
     *    to \ref samplePosition()
     *
     * \param sample
     *    A uniformly distributed 2D vector (or any value
     *    when \ref needsDirectionSample() == \c false)
     *
     * \return
     *    An importance weight associated with the sampled direction.
     *    This accounts for the difference between the directional part of the
     *    emission profile and the density function.
     */
    virtual Spectrum sampleCameraDirection(
            DirectionSamplingRecord &dRec,
            PositionSamplingRecord &pRec,
            const Point2 &sample,
            const Point2 *extra = NULL) const;

    virtual Spectrum sampleProjectorDirection(
            DirectionSamplingRecord &dRec,
            PositionSamplingRecord &pRec,
            Sampler *sampler,
            const Point2 &sample,
            const Point2 *extra = NULL) const;

    //s
    /**
     * \brief \a Direct sampling: given a reference point in the
     * scene, sample an emitter position that contributes towards it.
     *
     * Given an arbitrary reference point in the scene, this method
     * samples a position on the emitter that has a nonzero contribution
     * towards that point.
     * This can be seen as a generalization of direct illumination sampling
     * so that it works on both luminaires and sensors.
     *
     * Ideally, the implementation should importance sample the product of
     * the emission profile and the geometry term between the reference point
     * and the position on the emitter.
     *
     * The default implementation throws an exception.
     *
     * \param dRec
     *    A direct sampling record that specifies the reference point and
     *    a time value. After the function terminates, it will be
     *    populated with the position sample and related information
     *
     * \param sample
     *    A uniformly distributed 2D vector (or any value
     *    when \ref needsDirectSample() == \c false)
     *
     * \return
     *    An importance weight associated with the sample. Includes
     *    any geometric terms between the emitter and the reference point.
     */
    virtual Spectrum sampleCameraDirect(DirectSamplingRecord &dRec,
                                        const Point2 &sample) const;

    virtual Spectrum sampleProjectorDirect(DirectSamplingRecord &dRec,
                                           const Point2 &sample) const;

    //! @}
    // =============================================================

    // =============================================================
    //! @{ \name Query functions for the emission profile and
    //!          sampling density functions
    // =============================================================

    /**
     * \brief Evaluate the spatial component of the emission profile
     *
     * \param pRec
     *    A position sampling record, which specifies the query location
     *
     * \return The component of the emission profile that depends on
     * the position (i.e. emitted power per unit area for luminaires and
     * sensor response, or inverse power per unit area for sensors)
     */
    virtual Spectrum evalCameraPosition(const PositionSamplingRecord &pRec) const;

    virtual Spectrum evalProjectorPosition(const PositionSamplingRecord &pRec) const;

    /**
     * \brief Evaluate the directional component of the emission profile
     *
     * When querying a smooth (i.e. non-degenerate) component, it already
     * multiplies the result by the cosine foreshortening factor with
     * respect to the outgoing direction.
     *
     * \param dRec
     *    A direction sampling record, which specifies the query direction
     *
     * \param pRec
     *    A position sampling record, which specifies the query position
     *
     * \return The component of the emission profile that depends on
     * the direction (having units of 1/steradian)
     */

    virtual Spectrum evalCameraDirection(const DirectionSamplingRecord &dRec,
                                         const PositionSamplingRecord &pRec) const;

    virtual Spectrum evalProjectorDirection(const DirectionSamplingRecord &dRec,
                                            const PositionSamplingRecord &pRec) const;

    /**
     * \brief Evaluate the spatial component of the sampling density
     * implemented by the \ref samplePosition() method
     *
     * \param pRec
     *    A position sampling record, which specifies the query location
     *
     * \return
     *    The area density at the supplied position
     */
    virtual Float pdfCameraPosition(const PositionSamplingRecord &pRec) const;

    virtual Float pdfProjectorPosition(const PositionSamplingRecord &pRec) const;

    /**
     * \brief Evaluate the directional component of the sampling density
     * implemented by the \ref sampleDirection() method
     *
     * \param dRec
     *    A direction sampling record, which specifies the query direction
     *
     * \param pRec
     *    A position sampling record, which specifies the query position
     *
     * \return
     *    The directional density at the supplied position
     */

    virtual Float pdfCameraDirection(const DirectionSamplingRecord &dRec,
                                     const PositionSamplingRecord &pRec) const;

    virtual Float pdfProjectorDirection(const DirectionSamplingRecord &dRec,
                                        const PositionSamplingRecord &pRec) const;

    /**
     * \brief Evaluate the probability density of the \a direct sampling
     * method implemented by the \ref sampleDirect() method.
     *
     * \param dRec
     *    A direct sampling record, which specifies the query
     *    location. Note that this record need not be completely
     *    filled out. The important fields are \c p, \c n, \c ref,
     *    \c dist, \c d, \c measure, and \c uv.
     *
     * \return
     *    The density expressed with respect to the requested measure
     *    (usually \ref ESolidAngle)
     */
    virtual Float pdfCameraDirect(const DirectSamplingRecord &dRec) const;

    virtual Float pdfProjectorDirect(const DirectSamplingRecord &dRec) const;

    //! @}
    // =============================================================

    // =============================================================
    //! @{ \name Other query functions
    // =============================================================

    /**
     * \brief Return a listing of classification flags combined
     * using binary OR.
     *
     * \sa EProbeType
     */
    inline std::string getType() const { return m_type; }

    MTS_DECLARE_CLASS()
protected:
    /// Construct a new emitter instance
    Probe(const Properties &props);

    /// Unserialize a emitter instance from a binary data stream
    Probe(Stream *stream, InstanceManager *manager);

    /// Virtual destructor
    virtual ~Probe();

protected:
    std::string m_type;
    int32_t m_colTransform;
    int32_t m_rowTransform;
    Matrix3x3 m_epipolarMatrix;

};


class MTS_EXPORT_RENDER BasicProbe : public Probe {

public:
    void readFromProjector(Stream *stream);

    void readFromCamera(Stream *stream);

    void configureAfterLoadingCamProj();

    MTS_DECLARE_CLASS()
protected:
    /// Construct a new emitter instance
    BasicProbe(const Properties &props);

    /// Unserialize a emitter instance from a binary data stream
    BasicProbe(Stream *stream, InstanceManager *manager);

    /// Virtual destructor
    virtual ~BasicProbe();

protected:
    // Information loaded from the camera
    Float m_cameraNormalization;
    Float m_cameraNearClip;
    Float m_cameraFarClip;
    Vector2i m_cameraSize;
    Vector2 m_cameraResolution;
    Vector2 m_cameraInvResolution;
    ref<const AnimatedTransform> m_cameraWorldTransform;
    ref<const AABB2> m_cameraImageRect;
    Transform m_cameraToSample;
    Transform m_sampleToCamera;


    // Information loaded from a projector
    Float m_scale;
    Float m_projectorNearClip;
    Float m_projectorFarClip;
    Vector2i m_projectorSize;
    Float m_projectorNormalization;
    Vector2 m_projectorResolution;
    Vector2 m_projectorInvResolution;
    ref<const AnimatedTransform> m_projectorWorldTransform;
    ref<const AABB2> m_projectorImageRect;
    Transform m_projectorToSample;
    Transform m_sampleToProjector;
};

MTS_NAMESPACE_END

#endif //__MITSUBA_RENDER_PROBE_H_
